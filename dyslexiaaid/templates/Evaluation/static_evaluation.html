<!-- static_evaluation.html - COMPLETE VERSION -->
{% extends "base.html" %}
{% block content %}
<div class="relative z-10 max-w-4xl mx-auto p-6">
  <h2 class="text-2xl font-bold text-violet-900 mb-6">
    Evaluation Test â€“ {{ dyslexia_type }}
  </h2>
  <p class="text-gray-600 mb-6">
    Please complete the following {{ questions|length }} interactive questions to help us evaluate {{ dyslexia_type }}.
  </p>

  <form method="POST" class="space-y-6" id="evaluationForm">
    {% csrf_token %}
    
    <!-- Hidden inputs for data collection -->
    <input type="hidden" name="tts_usage" id="ttsUsageInput" value="[]">
    <input type="hidden" name="response_times" id="responseTimesInput" value="{}">
    <input type="hidden" name="start_time" id="startTimeInput" value="{{ request.session.evaluation_start_time }}">

    {% for question in questions %}
    <div class="p-4 bg-violet-50 rounded-xl shadow-sm question-container" 
         data-question-id="{{ question.id }}"
         data-interaction="{{ question.interaction }}"
         {% if "speech" in question.interaction or question.timed %}
         data-tts-text="{{ question.text }}"
         {% endif %}
         {% if question.timed %}
         data-time-limit="{{ question.time_limit }}"
         {% endif %}>
      
      <p class="font-medium text-gray-800 mb-2">{{ forloop.counter }}. {{ question.text }}</p>
      
      {% if question.hint %}
      <p class="text-sm text-violet-600 mb-3 italic">{{ question.hint }}</p>
      {% endif %}

      <!-- Speech Recognition Questions -->
      {% if question.interaction == "speech_recognition" %}
      <div class="flex items-center space-x-3 mb-3">
        <button type="button" class="tts-btn px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition" data-question-id="{{ question.id }}">ðŸ”Š Hear Question</button>
        <button type="button" class="record-btn px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition" data-question-id="{{ question.id }}">ðŸŽ¤ Record Answer</button>
        <span class="recording-status text-gray-600 text-sm">Click record to speak</span>
      </div>
      <div class="mt-2 hidden" id="result-{{ question.id }}">
        <p class="text-sm">You said: <span class="font-medium text-violet-700" id="transcript-{{ question.id }}"></span></p>
        <input type="hidden" name="q{{ question.id }}" id="input-{{ question.id }}">
      </div>
      {% endif %}

      <!-- Multiple Choice Questions -->
      {% if question.interaction == "multiple_choice" %}
      <div class="space-y-2">
        {% for option in question.options %}
        <label class="flex items-center p-2 rounded-lg hover:bg-violet-100 cursor-pointer transition">
          <input type="radio" name="q{{ question.id }}" value="{{ option }}" class="mr-2" required> 
          {{ option }}
        </label>
        {% endfor %}
      </div>
      {% endif %}

      <!-- Visual Exercises -->
      {% if question.id == 3 and dyslexia_type == "Visual dyslexia" %}
      <div class="mb-4 p-4 bg-white rounded-lg text-center text-lg font-mono">
        circle circle square triangle
      </div>
      {% endif %}

      <!-- Timed Exercises -->
      {% if question.timed %}
      <div class="flex justify-between items-center mb-3 p-2 bg-white rounded-lg">
        <span class="font-medium text-sm">Time limit: {{ question.time_limit }} seconds</span>
        <span class="timer text-violet-600 font-bold" data-time-limit="{{ question.time_limit }}">{{ question.time_limit }}</span>
      </div>
      
      <!-- Visual aids for timed exercises -->
      {% if question.id == 1 and dyslexia_type == "Rapid naming deficit" %}
      <div class="mb-4 p-4 bg-white rounded-lg">
        <div class="flex justify-center space-x-6 text-lg font-semibold">
          <span class="text-red-600">RED</span>
          <span class="text-yellow-600">YELLOW</span>
          <span class="text-blue-600">BLUE</span>
          <span class="text-green-600">GREEN</span>
        </div>
        <p class="text-center text-sm text-gray-600 mt-2">Say these color names in order</p>
      </div>
      {% endif %}
      
      {% if question.id == 3 and dyslexia_type == "Rapid naming deficit" %}
      <div class="mb-4 p-4 bg-white rounded-lg">
        <div class="flex justify-center space-x-6 text-lg font-semibold">
          <span>STAR</span>
          <span>HEART</span>
          <span>DIAMOND</span>
          <span>CLUB</span>
        </div>
        <p class="text-center text-sm text-gray-600 mt-2">Say these shape names in order</p>
      </div>
      {% endif %}
      
      {% if question.id == 5 and dyslexia_type == "Rapid naming deficit" %}
      <div class="mb-4 p-4 bg-white rounded-lg">
        <div class="flex justify-center space-x-6 text-lg font-semibold">
          <span>DOG</span>
          <span>CAT</span>
          <span>MOUSE</span>
          <span>RABBIT</span>
        </div>
        <p class="text-center text-sm text-gray-600 mt-2">Say these animal names in order</p>
      </div>
      {% endif %}
      
      <button type="button" class="start-timing px-4 py-2 bg-violet-600 text-white rounded-lg hover:bg-violet-700 transition w-full" data-question-id="{{ question.id }}">
        Start Timed Exercise
      </button>
      <div class="record-section mt-3 hidden">
        <button type="button" class="record-timed-btn px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition" data-question-id="{{ question.id }}">
          ðŸŽ¤ Start Recording
        </button>
        <span class="recording-status-timed text-gray-600 text-sm ml-3">Click to record your answer</span>
      </div>
      <input type="hidden" name="q{{ question.id }}" id="timed-input-{{ question.id }}">
      {% endif %}

    </div>
    {% endfor %}

    <!-- Submit Button -->
    <div class="text-center mt-8">
      <button type="submit"
        class="px-6 py-3 bg-violet-600 text-white font-semibold rounded-xl shadow-md hover:bg-violet-700 transition">
        Submit Evaluation
      </button>
    </div>
  </form>
</div>

<!-- Enhanced Speech & Data Collection JS -->
<script>
class SpeechHelper {
    constructor() {
        this.recognition = null;
        this.isRecording = false;
        this.currentQuestionId = null;
        this.timedResponse = "";
        
        // NEW: Data collection properties
        this.ttsUsage = new Set();
        this.responseTimes = {};
        this.startTime = Date.now();

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            this.recognition = new SpeechRecognition();
            this.recognition.continuous = false;
            this.recognition.interimResults = false;
            this.recognition.lang = 'en-US';

            this.recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                this.handleRecognitionResult(transcript);
            };

            this.recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                this.updateStatus('Error: ' + event.error, 'error');
            };

            this.recognition.onend = () => {
                this.isRecording = false;
            };
        }
    }

    // NEW: Track TTS usage
    trackTTSUsage(questionId) {
        this.ttsUsage.add(questionId);
        console.log(`TTS used for question ${questionId}`);
        this.updateHiddenInputs();
    }

    // NEW: Track response time for questions
    startQuestionTimer(questionId) {
        this.responseTimes[questionId] = Date.now();
    }

    // NEW: Calculate and store processing time
    endQuestionTimer(questionId) {
        if (this.responseTimes[questionId]) {
            const timeTaken = (Date.now() - this.responseTimes[questionId]) / 1000; // Convert to seconds
            this.responseTimes[questionId] = timeTaken;
            this.updateHiddenInputs();
            return timeTaken;
        }
        return 0;
    }

    // NEW: Update hidden form inputs with collected data
    updateHiddenInputs() {
        document.getElementById('ttsUsageInput').value = JSON.stringify(Array.from(this.ttsUsage));
        document.getElementById('responseTimesInput').value = JSON.stringify(this.responseTimes);
    }

    // NEW: Get all collected data
    getCollectedData() {
        return {
            tts_usage: Array.from(this.ttsUsage),
            response_times: this.responseTimes,
            start_time: this.startTime / 1000,
            total_time: (Date.now() - this.startTime) / 1000
        };
    }

    startRecording(questionId, isTimed = false) {
        this.startQuestionTimer(questionId); // NEW: Start timing when recording begins
        
        if (!this.recognition) {
            alert('Speech recognition not supported in your browser. Use Chrome or Edge.');
            return;
        }
        
        if (this.isRecording) {
            this.recognition.stop();
        }
        
        this.currentQuestionId = questionId;
        this.isRecording = true;
        
        if (isTimed) {
            this.updateTimedStatus('Recording... Speak now!', 'recording');
        } else {
            this.updateStatus('Recording... Speak now!', 'recording');
        }

        try { 
            this.recognition.start(); 
        } catch (error) { 
            console.error('Recognition start error:', error);
            this.isRecording = false;
        }
    }

    handleRecognitionResult(transcript) {
        const processingTime = this.endQuestionTimer(this.currentQuestionId); // NEW: Capture processing time
        
        if (this.currentQuestionId) {
            const container = document.querySelector(`[data-question-id="${this.currentQuestionId}"]`);
            const isTimed = container.querySelector('.start-timing') && container.querySelector('.start-timing').disabled;
            
            if (isTimed) {
                this.timedResponse = transcript;
                document.getElementById(`timed-input-${this.currentQuestionId}`).value = transcript;
                this.updateTimedStatus('Recording complete!', 'complete');
                
                // NEW: Log STT result with timing
                console.log(`Timed Q${this.currentQuestionId}: "${transcript}" (${processingTime.toFixed(2)}s)`);
            } else {
                document.getElementById(`transcript-${this.currentQuestionId}`).textContent = transcript;
                document.getElementById(`input-${this.currentQuestionId}`).value = transcript;
                document.getElementById(`result-${this.currentQuestionId}`).classList.remove('hidden');
                this.updateStatus('Recording complete!', 'complete');
                
                // NEW: Log STT result with timing
                console.log(`Q${this.currentQuestionId}: "${transcript}" (${processingTime.toFixed(2)}s)`);
            }
        }
        this.isRecording = false;
    }

    updateStatus(message, type) {
        if (this.currentQuestionId) {
            const statusElement = document.querySelector(`[data-question-id="${this.currentQuestionId}"] .recording-status`);
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `recording-status text-sm ${
                    type === 'recording' ? 'text-red-600 font-medium' : 
                    type === 'complete' ? 'text-green-600 font-medium' : 
                    type === 'error' ? 'text-red-600 font-medium' : 'text-gray-600'
                }`;
            }
        }
    }

    updateTimedStatus(message, type) {
        if (this.currentQuestionId) {
            const statusElement = document.querySelector(`[data-question-id="${this.currentQuestionId}"] .recording-status-timed`);
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `recording-status-timed text-sm ${
                    type === 'recording' ? 'text-red-600 font-medium' : 
                    type === 'complete' ? 'text-green-600 font-medium' : 
                    type === 'error' ? 'text-red-600 font-medium' : 'text-gray-600'
                }`;
            }
        }
    }

    playTTS(text) {
        if ('speechSynthesis' in window) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US';
            utterance.rate = 0.9;
            speechSynthesis.speak(utterance);
        }
    }
}

const speechHelper = new SpeechHelper();

document.addEventListener('DOMContentLoaded', () => {
    // TTS buttons - ENHANCED with data tracking
    document.querySelectorAll('.tts-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const questionId = btn.dataset.questionId;
            const container = btn.closest('.question-container');
            const text = container.dataset.ttsText;
            
            // NEW: Track TTS usage
            speechHelper.trackTTSUsage(questionId);
            speechHelper.playTTS(text);
        });
    });

    // Record buttons for regular speech questions
    document.querySelectorAll('.record-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const questionId = btn.dataset.questionId;
            speechHelper.startRecording(questionId);
        });
    });

    // Record buttons for timed exercises
    document.querySelectorAll('.record-timed-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const questionId = btn.dataset.questionId;
            speechHelper.startRecording(questionId, true);
        });
    });

    // Timed exercises
    document.querySelectorAll('.start-timing').forEach(button => {
        button.addEventListener('click', function() {
            const questionId = this.dataset.questionId;
            const container = this.closest('.question-container');
            const timerElement = container.querySelector('.timer');
            const timeLimit = parseInt(container.dataset.timeLimit);
            const recordSection = container.querySelector('.record-section');

            button.disabled = true;
            button.textContent = 'Exercise Started...';
            button.classList.add('bg-orange-500');
            recordSection.classList.remove('hidden');

            let timeLeft = timeLimit;
            const countdown = setInterval(() => {
                timeLeft--;
                timerElement.textContent = timeLeft;
                
                if (timeLeft <= 3) {
                    timerElement.classList.add('text-red-600', 'animate-pulse');
                }
                
                if (timeLeft <= 0) {
                    clearInterval(countdown);
                    button.textContent = 'Time\'s Up!';
                    button.classList.remove('bg-orange-500');
                    button.classList.add('bg-red-500');
                    recordSection.classList.add('hidden');
                    
                    // Auto-submit if no response recorded
                    if (!document.getElementById(`timed-input-${questionId}`).value) {
                        document.getElementById(`timed-input-${questionId}`).value = 'no_response';
                    }
                }
            }, 1000);
        });
    });

    // ENHANCED Form submission with data collection
    document.getElementById('evaluationForm').addEventListener('submit', function(e) {
        // Add collected data to form before submission
        const collectedData = speechHelper.getCollectedData();
        
        // Update hidden inputs with final data
        document.getElementById('ttsUsageInput').value = JSON.stringify(collectedData.tts_usage);
        document.getElementById('responseTimesInput').value = JSON.stringify(collectedData.response_times);
        document.getElementById('startTimeInput').value = collectedData.start_time;
        
        console.log('Submitting evaluation data:', collectedData);
        
        // Validation
        let allAnswered = true;
        const questions = document.querySelectorAll('.question-container');
        
        questions.forEach(container => {
            const questionId = container.dataset.questionId;
            const interaction = container.dataset.interaction;
            let answered = false;
            
            if (interaction === 'multiple_choice') {
                answered = container.querySelector(`input[name="q${questionId}"]:checked`);
            } else {
                const input = document.getElementById(`input-${questionId}`) || 
                             document.getElementById(`timed-input-${questionId}`);
                answered = input && input.value && input.value !== 'no_response';
            }
            
            if (!answered) {
                allAnswered = false;
                container.classList.add('border-2', 'border-red-500');
            } else {
                container.classList.remove('border-2', 'border-red-500');
            }
        });
        
        if (!allAnswered) {
            e.preventDefault();
            alert('Please answer all questions before submitting.');
        } else {
            console.log('All questions answered, submitting form...');
        }
    });

    // NEW: Track multiple choice selections for timing
    document.querySelectorAll('input[type="radio"]').forEach(radio => {
        radio.addEventListener('change', function() {
            const questionId = this.name.replace('q', '');
            if (!speechHelper.responseTimes[questionId]) {
                speechHelper.responseTimes[questionId] = (Date.now() - speechHelper.startTime) / 1000;
                speechHelper.updateHiddenInputs();
            }
        });
    });
});
</script>

<style>
.recording-status.recording, .recording-status-timed.recording {
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

.bg-violet-50 { background-color: #f5f3ff; }
.bg-violet-100 { background-color: #ede9fe; }
.bg-violet-600 { background-color: #7c3aed; }
.bg-violet-700 { background-color: #6d28d9; }
.text-violet-600 { color: #7c3aed; }
.text-violet-700 { color: #6d28d9; }
</style>
{% endblock %}